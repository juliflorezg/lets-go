package main

import (
	"net/http"
	"net/url"
	"testing"

	"github.com/juliflorezg/lets-go/internal/assert"
)

func TestPing(t *testing.T) {
	// // Initialize a new httptest.ResponseRecorder.
	// rr := httptest.NewRecorder()

	// // Initialize a new dummy http.Request.
	// r, err := http.NewRequest(http.MethodGet, "/", nil)
	// if err != nil {
	// 	t.Fatal(err)
	// }

	// // Call the ping handler function, passing in the
	// // httptest.ResponseRecorder and http.Request.
	// ping(rr, r)

	// // Call the Result() method on the http.ResponseRecorder to get the
	// // http.Response (request response) generated by the ping handler.
	// rs := rr.Result()

	// // Check that the status code written by the ping handler was 200.
	// assert.Equal(t, rs.StatusCode, http.StatusOK)

	// // And we can check that the response body written by the ping handler
	// // equals "OK"
	// defer rs.Body.Close()
	// body, err := io.ReadAll(rs.Body)
	// if err != nil {
	// 	t.Fatal(err)
	// }

	// body = bytes.TrimSpace(body)
	// assert.Equal(t, string(body), "OK")

	//~ E2E test of ping handler

	// Create a new instance of our application struct. For now, this just
	// contains a structured logger (which discards anything written to it)
	app := NewTestApplication(t)

	ts := NewTestServer(t, app.routes())
	defer ts.Close()

	status, _, body := ts.get(t, "/ping")

	assert.Equal(t, status, http.StatusOK)
	assert.Equal(t, body, "OK")
}

func TestSnippetView(t *testing.T) {
	// create a new test struct app
	app := NewTestApplication(t)

	// create a new test server
	ts := NewTestServer(t, app.routes())
	defer ts.Close()

	// define the struct for table-driven tests
	tests := []struct {
		name     string
		urlPath  string
		wantCode int
		wantBody string
	}{
		{
			name:     "Valid ID",
			urlPath:  "/snippet/view/1",
			wantCode: http.StatusOK,
			wantBody: "Sample content for snippet 1",
		},

		{
			name:     "Non-existent ID",
			urlPath:  "/snippet/view/2",
			wantCode: http.StatusNotFound,
		},
		{
			name:     "Negative ID",
			urlPath:  "/snippet/view/-5",
			wantCode: http.StatusNotFound,
		},
		{
			name:     "Decimal ID",
			urlPath:  "/snippet/view/1.234",
			wantCode: http.StatusNotFound,
		},
		{
			name:     "String ID",
			urlPath:  "/snippet/view/abc",
			wantCode: http.StatusNotFound,
		},
		{
			name:     "Empty ID",
			urlPath:  "/snippet/view/",
			wantCode: http.StatusNotFound,
		},
	}

	// do the sub-tests
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			code, _, body := ts.get(t, tt.urlPath)

			assert.Equal(t, code, tt.wantCode)
			if tt.wantBody != "" {
				assert.StringContains(t, body, tt.wantBody)
			}
		})
	}

}

func TestUserSignUp(t *testing.T) {
	// Create the application struct containing our mocked dependencies and set
	// up the test server for running an end-to-end test.
	app := NewTestApplication(t)
	ts := NewTestServer(t, app.routes())
	defer ts.Close()

	// Make a GET /user/signup request and then extract the CSRF token from the
	// response body
	_, _, body := ts.get(t, "/user/signup")

	validCSRFToken := extractCSRFToken(t, body)

	// Log the CSRF token value in our test output using the t.Logf() function.
	// The t.Logf() function works in the same way as fmt.Printf(), but writes
	// the provided message to the test output.
	t.Logf("The CSRF token is: %q", validCSRFToken)

	const (
		validName     = "Rob"
		validPassword = "validPa$$word"
		validEmail    = "rob@example.com"
		// formTag is used to check that when we pass incorrect data, the response contains the same signup form (page has recharged the form with relevant errors) so the same form tag must be present in response body
		formTag = `<form action="/user/signup" method="POST" novalidate>`
	)

	// add the table-driven tests
	tests := []struct {
		name         string
		userName     string
		userEmail    string
		userPassword string
		csrfToken    string
		wantCode     int
		wantFormTag  string
	}{
		{
			name:         "Valid submission",
			userName:     validName,
			userEmail:    validEmail,
			userPassword: validPassword,
			csrfToken:    validCSRFToken,
			wantCode:     http.StatusSeeOther,
		},
		{
			name:         "Invalid CSRF Token",
			userName:     validName,
			userEmail:    validEmail,
			userPassword: validPassword,
			csrfToken:    "wrongToken",
			wantCode:     http.StatusBadRequest,
		},
		{
			name:         "Empty name",
			userName:     "",
			userEmail:    validEmail,
			userPassword: validPassword,
			csrfToken:    validCSRFToken,
			wantCode:     http.StatusUnprocessableEntity,
			wantFormTag:  formTag,
		},
		{
			name:         "Empty email",
			userName:     validName,
			userEmail:    "",
			userPassword: validPassword,
			csrfToken:    validCSRFToken,
			wantCode:     http.StatusUnprocessableEntity,
			wantFormTag:  formTag,
		},
		{
			name:         "Empty password",
			userName:     validName,
			userEmail:    validEmail,
			userPassword: "",
			csrfToken:    validCSRFToken,
			wantCode:     http.StatusUnprocessableEntity,
			wantFormTag:  formTag,
		},
		{
			name:         "Invalid email",
			userName:     validName,
			userEmail:    "bob@example.",
			userPassword: validPassword,
			csrfToken:    validCSRFToken,
			wantCode:     http.StatusUnprocessableEntity,
			wantFormTag:  formTag,
		},
		{
			name:         "Short password",
			userName:     validName,
			userEmail:    validEmail,
			userPassword: "pa$$",
			csrfToken:    validCSRFToken,
			wantCode:     http.StatusUnprocessableEntity,
			wantFormTag:  formTag,
		},
		{
			name:         "Duplicate email",
			userName:     validName,
			userEmail:    "dupe@example.com",
			userPassword: validPassword,
			csrfToken:    validCSRFToken,
			wantCode:     http.StatusUnprocessableEntity,
			wantFormTag:  formTag,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			form := url.Values{}
			form.Add("name", tt.userName)
			form.Add("email", tt.userEmail)
			form.Add("password", tt.userPassword)
			form.Add("csrf_token", tt.csrfToken)
			code, _, body := ts.postForm(t, "/user/signup", form)

			assert.Equal(t, code, tt.wantCode)
			if tt.wantFormTag != "" {
				assert.StringContains(t, body, tt.wantFormTag)
			}
		})
	}
}

func TestSnippetCreate(t *testing.T) {
	app := NewTestApplication(t)
	ts := NewTestServer(t, app.routes())
	defer ts.Close()

	t.Run("Unauthenticated user", func(t *testing.T) {
		status, header, _ := ts.get(t, "/snippet/create")

		assert.Equal(t, status, http.StatusSeeOther)
		assert.Equal(t, header.Get("Location"), "/user/login")

	})

	t.Run("Authenticated user", func(t *testing.T) {
		_, _, body := ts.get(t, "/user/login")

		validCSRFToken := extractCSRFToken(t, body)

		const (
			validEmail    = "alice@example.com"
			validPassword = "pa$$word"
		)
		form := url.Values{}
		form.Add("email", validEmail)
		form.Add("password", validPassword)
		form.Add("csrf_token", validCSRFToken)
		ts.postForm(t, "/user/login", form)

		status, _, body := ts.get(t, "/snippet/create")

		assert.Equal(t, status, http.StatusOK)
		assert.StringContains(t, body, `<form action="/snippet/create" method="POST">`)
	})
}
